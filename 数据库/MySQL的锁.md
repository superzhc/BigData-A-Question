# MySQL 的锁

> 锁是在执行多线程时，用于强行限制资源访问的同步机制，即用在并发控制中保证对互斥的要求。
> 
> 一般的锁是建议锁（advisory lock），每个线程在访问对应资源前都需获取锁的信息，再根据信息决定是否可以访问。若访问对应信息，锁的状态会改变为锁定，因此其它线程此时不会来访问该资源，当资源结束后，会恢复锁的状态，允许其他线程的访问。
> 
> 有些系统有强制锁（mandatory lock），若有未授权的线程想要访问锁定的数据，在访问时就会产生异常。

数据库的锁根据不同划分方式有很多种说法，在业务访问上有以下两种：

- 排他锁
  在访问共享资源之前对其进行加锁，在访问完成后进行解锁操作。 加锁成功后，任何其它线程请求来获取锁都会被阻塞，直到当前线自行释放锁。
- 共享锁
  被加锁资源是可被共享的，但仅限于读请求。它的写请求只能被获取到锁的请求独占。 也就是加了共享锁的数据，只能够当前线程修改，其它线程只能读数据，并不能修改。

除加锁读外，还有一种不加锁读的情况。这种方式称为快照读，读请求加锁称为共享读。

如果按照锁的颗粒度划分看，就有表锁和行锁

- 表锁：是MySQL中最基本的锁策略，并且是开销最小的策略。并发处理较少。表锁由MySQL服务或存储引擎管理。多数情况由服务层管理，具体看SQL操作。
  例如：服务器会为诸如 ALTER TABLE 之类的语句使用表锁，而忽略存储引擎的锁。
  加锁机制:它会锁定整张表。一个用户在对表进行写操作（插人、删除、更新等)前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获取到读锁。
- 行锁:锁定当前访问行的数据，并发处理能力很强。但锁开销最大。具体视行数据多少决定。由innoDB存储引擎支持。
- 页级锁：页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。因此，采取了折衷的页级锁，一次锁定相邻的一组记录。由BDB 存储引擎管理页级锁。

