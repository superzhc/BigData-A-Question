<!--
 * @Github       : https://github.com/superzhc/BigData-A-Question
 * @Author       : SUPERZHC
 * @CreateDate   : 2021-01-28 16:49:17
 * @LastEditTime : 2021-01-29 17:41:18
 * @Copyright 2021 SUPERZHC
-->
# 模块机制

Node.js 中的模块可以分为原生模块和文件模块。在 Node.js 中可以通过 require 方法导入模块、exports 方法导出模块。

## require 导入模块

对于原生模块（如 http），只需要使用 `require('http')` 导入这个模块并将其赋值给一个变量即可使用这个模块导出的属性、方法等。

```js
const http = require("http");
http.createServer(
    // code
);
```

对于文件模块，可以使用 `./` 前缀来指代当前路径，从而使用相对路径来加载模块。加载模块时，可以省略 `.js` 拓展名。例如，在同级的文件夹 node 中有一个名为 `myModule.js` 的文件模块，可以这样导入：

```js
const myModule = require("./node/myModule");
```

对于利用 NPM 下载的模块，那么在 node_modules 文件夹的同级目录可以这样加载：

```js
const underscore = require("./underscore");
```

这是因为 Node.js 内部会自动查找加载 node_modeles 文件夹下的模块。

## exports 导出模块

一个模块中的变量和方法只能用于这个模块，如果想要与其他模块共享一些方法、属性等，就可以用 exports 导出一个对象。这个对象可以包含想要与其他模块共享的方法和属性等。

## 模块实现

在 Node.js 中引入模块，需要经历如下3个步骤：

1. 路径分析
2. 文件定位
3. 编译执行

在 Node.js 中，模块分为两类：一类是 Node.js 提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。

- 核心模块部分在 Node.js 源代码的编译过程中，编译进了二进制执行文件。在 Node.js 进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。
- 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。

注：Node.js 对引入过的模块都会进行缓存，以减少二次引入时的开销。

### 路径分析

**核心模块**

核心模块的优先级仅次于缓存加载，它在 Node.js 的源代码编译过程中已经编译为二进制代码，其加载过程最快。

如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个 http 用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。

**路径形式的文件模块**

以`.`、`..` 和 `/` 开始的标识符，这里都被当做文件模块来处理。在分析文件模块时，`require()` 方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。

由于文件模块给 Node.js 指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块。

**自定义模块**

自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。

模块路径是 Node.js 在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。模块路径的生成规则如下所示：

1. 当前文件目录下的 node_modules 目录。
2. 父目录下的 node_modules 目录。
3. 父目录的父目录下的 node_modules 目录。
4. 沿路径向上逐级递归，直到根目录下的 node_modules 目录。

### 文件定位

**文件扩展名分析**

`require()` 在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。这种情况下，Node.js 会按 `.js`、`.json`、`.node` 的次序补足扩展名，依次尝试。

